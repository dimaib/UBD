///////////////////////////////////////////////////////////////////////
/************Библиотека для работы с акселерометром LIS302************/
///////////////////////////////////////////////////////////////////////
//#include <stdlib.h>
#include "i2c.h"						//библиотека констант и функций для работы с софтовым i2c
#include "main.h"						//библиотека хранения общих констант проекта

void print_w(const char *s);//Отправка строки. С ожиданием

//адреса регистров акселерометра
#define Who_am_i			0x0F		//идентификатор акселерометра
#define Ctrl_reg_1			0x20        //регистр конфигурации 1
#define Ctrl_reg_2			0x21        //регистр конфигурации 2
#define Ctrl_reg_3			0x22        //регистр конфигурации 3
#define Status_reg			0x27        //регистрор флагов событий
#define Ff_wu_cfg_1			0x30        //Регистр условий прерывания для FF_WU_1
#define Ff_wu_cfg_2			0x34        //Регистр условий прерывания для FF_WU_2
#define Ff_wu_src_1			0x31        //Флаговый регистр прерываний для FF_WU_1
#define Ff_wu_src_2			0x35        //Флаговый регистр прерываний для FF_WU_2
#define Ff_wu_ths_1			0x32        //Регистр порогового значения для FF_WU_1
#define Ff_wu_ths_2			0x36        //Регистр порогового значения для FF_WU_2
#define Ff_wu_duration_1	0x33		//Регистр максимального продолжения события для FF_WU_1
#define Ff_wu_duration_2	0x37		//Регистр максимального продолжения события для FF_WU_2
#define Xout				0x29        //Регистр выхода значения по X
#define Yout				0x2B        //Регистр выхода значения по Y
#define Zout				0x2D        //Регистр выхода значения по Z
//адреса регистров акселерометра

//параметры для настройки акселерометра
#define Dr					0           //частота выборки 1=400Гц, 0=100Гц
#define Pd					1           //бит управления питанием акселерометра
#define Fs					1			//выбор диапазона измерений 1=8g, 0=2g
#define Stp					0           //самодиагностика stp\stm:
#define Stm					0           //0\0-выключена, 0\1-режим Р, 1\0 режим М
#define Zen					1			//бит разрешения тактирования оси Z
#define Yen					1           //бит разрешения тактирования оси Y
#define Xen					1           //бит разрешения тактирования оси X
#define Fds					1           //бит фильтра гравитации 0=реагирует на гравитацию, 1=не реагирует на гравитацию
#define Hp_ff_wu1			1			//бит вкл\выкл фильтр верхних частот для генератора прерываний FF_WU1
#define Hp_ff_wu2			1			//бит вкл\выкл фильтр верхних частот для генератора прерываний FF_WU2
#define Hp_coef1			0           //частота среза фильтра верхних частот DR0\1  coef1\coef2
#define Hp_coef2			1           //0\0=2\8Гц, 1\0=1\4Гц, 0\1=0.5\2Гц, 1\1=0.25\1Гц
#define Ihl					0           //0=при срабатывании прерывания INT устанавливается в единицу и наоборот
#define Pp_od				0           //тип выводов. 0=push-pull, 1=открытый коллектор
#define I1cfg				1           //Источник прерывания INT1 и INT2. 000-прерывание выключено, 001-FF_WU_1, 010-FF_WU_2
#define I2cfg				8           //011-FF_WU_1|FF_WU_2, 100-Данные готовы, 111-прерывание от клика
#define Aoi					0           //0прерывание происходит при любом из событий, 1=при возникновении всех событий
#define Lir					1           //1=при чтении регистра FF_WU_SRC_1\2, его дынные обнулятся и наоборот
#define Xhie				1           //1=событие по превышению порогового значения по оси X, 0=событие отключено
#define Yhie				1           //1=событие по превышению порогового значения по оси Y, 0=событие отключено
#define Zhie				1           //1=событие по превышению порогового значения по оси Z, 0=событие отключено
#define Xlie				0           //1=событие по понижению порогового значения по оси X, 0=событие отключено
#define Ylie				0           //1=событие по понижению порогового значения по оси Y, 0=событие отключено
#define Zlie				0           //1=событие по понижению порогового значения по оси Z, 0=событие отключено
#define Dcrm				0           //0=счётчик сбрасывается, 1=счётчик декриментируется
#define Ths					127         //пороговое значение по осям. Максимум 127
#define Ff_wu_duration		255         //минимальная продолжительность события. Если частота 100Гц, то 0..2.55с, если
#define R_lis				0x3B        //константа чтения из I2C
#define W_lis				0x3A        //константа записи в I2C
#define RES_SETTINGS        0x5C        //конфигурация битов для сброса настроек акселерометра
#define OK_ACCEL			0x3B		//идентификатор LIS302
//параметры для настройки акселерометра

#define POS_NUM				30			//кол-во измерений при определени положения в пространстве

//переменные для акселерометра	
extern signed char x, y, z;											//для чтения значений осейиз акселерометра
extern char x_pos, y_pos, z_pos;									//для переопределения осей при сканировании положения в пространстве
//переменные для акселерометра

void lis_write(char reg/*адрес регистра*/, char byte/*значение для записи*/)	//функция записи байта в акселерометр
{
	i2c_start_cond();												//начало передачи
	i2c_send_byte (W_lis);											//команда на запись
	i2c_send_byte (reg);											//адрес регистра
	i2c_send_byte (byte);											//байт, который записываем в регистр
	i2c_stop_cond();												//конец передачи
}

unsigned char lis_read(char reg/*адрес регистра*/)					//чтение значения регистра из акселерометра
{
	unsigned char data=0;											//переменная для записи в неё считанного значения
	i2c_start_cond();												//начало передачи
	i2c_send_byte (W_lis);											//команда на запись
	i2c_send_byte (reg);											//адрес регистра
	i2c_restart_cond();												//рестарт шины
	i2c_send_byte (R_lis);											//команда на чтение
	data=i2c_get_byte (1);											//получение байта
	i2c_restart_cond();												//рестарт шины
	i2c_stop_cond();												//конец передачи
	return data;
}

unsigned char init_lis302(char FDS/*разрешение фильтрации земли*/)	//инициализация акселерометрна
{
	lis_write(Ctrl_reg_2,RES_SETTINGS);								//сброс настроек акселерометра
	lis_read(Ff_wu_src_1); lis_read(Ff_wu_src_2);					//сброс прерываний акселерометра
	//инициализация и настройка основных регистров акселерометра
	lis_write(Ctrl_reg_1, (Dr<<7)|(Pd<<6)|(Fs<<5)|(Stp<<4)|(Stm<<3)|(Zen<<2)|(Yen<<1)|(Xen<<0));
	lis_write(Ctrl_reg_2, (0<<7)|(0<<6)|(0<<5)|(FDS<<4)|(Hp_ff_wu2<<3)|(Hp_ff_wu1<<2)|(Hp_coef2<<1)|(Hp_coef1<<0));
	lis_write(Ctrl_reg_3, (Ihl<<7)|(Pp_od<<6)|I2cfg|I1cfg);
	lis_write(Ff_wu_cfg_1, (Aoi<<7)|(Lir<<6)|(Zhie<<5)|(Zlie<<4)|(Yhie<<3)|(Ylie<<2)|(Xhie<<1)|(Xlie<<0));
	lis_write(Ff_wu_cfg_2, (Aoi<<7)|(Lir<<6)|(Zhie<<5)|(Zlie<<4)|(Yhie<<3)|(Ylie<<2)|(Xhie<<1)|(Xlie<<0));
	lis_write(Ff_wu_ths_1, (Dcrm<<7)|Ths);
	lis_write(Ff_wu_ths_2, (Dcrm<<7)|Ths);
	lis_write(Ff_wu_duration_1, Ff_wu_duration);
	lis_write(Ff_wu_duration_2, Ff_wu_duration);
	//инициализация и настройка основных регистров акселерометра
	return lis_read(Who_am_i);										//возвращаем результат считаный из акселерометра(идентификатор микросхемы 0x3B)
}

void read_xyz()														//функция для чтения значений по осям
{													
	x=lis_read(x_pos); y=lis_read(y_pos); z=lis_read(z_pos);		//получение значений по осям
	x=abs(x); y=abs(y); z=abs(z);									//значения по модулю
	if(!x) x=1;														//если значение равно нулю, то присвоить ему единицу
	if(!y) y=1;														//если значение равно нулю, то присвоить ему единицу
	if(!z) z=1;														//если значение равно нулю, то присвоить ему единицу
	if(x>5||y>5||z>5) SET_LED else RES_LED							//проверка работы акселерлметра
}

void position_space()												//функция определения положения устройства в пространстве
{
	signed int x_sum=0, y_sum=0, z_sum=0;							//переменные для суммирования показаний осей акселерометра
	print_w("Accel position space");
	for(unsigned char i=0;i<POS_NUM;i++){
		read_xyz();
		x_sum+=(x);													//суммрование значений осей для вычисления среднего
		y_sum+=(y);													//суммрование значений осей для вычисления среднего
		z_sum+=(z);													//суммрование значений осей для вычисления среднего		
		TOGGLE_LED
		print_w(".");
		_delay_ms(20);
	}
	x_sum/=POS_NUM; y_sum/=POS_NUM; z_sum/=POS_NUM;
	if(x_sum>=10){													//условие корректировки осей, по результатам измерений
		x_pos=Zout; y_pos=Yout; z_pos=Xout;
		print_w("X -> ");
	}else if(y_sum>=10){
		x_pos=Zout; y_pos=Xout; z_pos=Yout;
		print_w("Y -> ");
	}else if(z_sum>=10){
		x_pos=Xout; y_pos=Yout; z_pos=Zout;
		print_w("Z -> ");
	}
	print_w("OK\r\n");
}